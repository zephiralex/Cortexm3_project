#include <STM32FreeRTOS.h>

// указатели на константы типа char, для имитации строки
// используя static мы экономим RAM память контроллера
static const char* Task1 = "Задание1";
static const char* Task2 = "Задание2";
static const char* Task3 = "Задание3";


QueueHandle_t Ochered; // создаем очередь для обмена сообщений между потоками, вместо глобальной переменной
SemaphoreHandle_t Mutex;  // Объявление переменной типа семафор (мьютекс), для "единоличного удержания" функционала
SemaphoreHandle_t Semafor; // создаем сигнал к действию для потока типа семафор

// объявляем глобальную переменную типа Int для записи данных работы потоков
int count = 1;


void setup() {
  Serial.begin(115200); // инициализируем серийный порт на скорости 115200 бод;
  Serial.write(12); // очищение вывода в мониторе ресурса, для отладки через ПО CoolTerm

  //  исключительно ради любопытсва, т.к. мы говорили про "кучу" на собеседовании
  void *kucha_init = pvPortMalloc(1); //инициализация кучи с выделением 1 байта памяти, это необходимо чтоб заработала функция xPortGetFreeHeapSize();
  if (kucha_init != NULL) 
    vPortFree(kucha_init); // освобождаем 1 байт памяти после инициализации

  Serial.print("Свободная память до создания задач, очереди, мьютекса и семафора:");
  Serial.println(xPortGetFreeHeapSize());

  Ochered = xQueueCreate(3, sizeof(char*)); // создаем объект типа очередь из 3 элементов, больше нам не надо, а будет не влазить - есть функции обработчики ошибок
  Mutex = xSemaphoreCreateMutex(); // создание мьютекса
  Semafor = xSemaphoreCreateBinary(); // создание семафора

  // Задача1 и задача2 использует одинаковые приоритет и выполняется по равному принципу Round Robin - равное время на выполнение задач
  xTaskCreate(task_que,       // Создаем задачу с запуском функции "task_que"
              "Задание 1",    // названием "Задание 1" - для отладочной информации (я так понимаю через Stm32IdeCube)
              128,            // размером 128 слов (512 байт)
              (void*)Task1,   // с указанием на адрес константы Task1
              2,              // повышенный приоритет
              NULL);          // хэндл задачи, нужен для обращения к ней, например для освобождения памяти, если задача не пригодится
  xTaskCreate(task_que, "Задание 2", 128, (void*)Task2, 2, NULL);     // аналогично задаче1
  xTaskCreate(task_sema, "Задание 3", 128, (void*)Task3, 1, NULL);    // задание 3 с меньшим приоритетом и вызывается по сигналу семафора

  Serial.print("Свободная памяти после создания объектов: ");
  Serial.println(xPortGetFreeHeapSize());  // прочитал про интересный функционал, увидел на практике, что задачи занимают очень много памяти
  
  xQueueSend(Ochered, &count, 10);    //  Помещаем в очередь значение переменной 1, чтобы по условию начало выполнятсья задание №1
  
  vTaskStartScheduler();  //  задачи созданы, запускаем планировщик
}

// loop при FreeRTOS не используется
void loop() {
}

// описываем функцию задачи с очередью и вызовом семафора, для 3 задачи
void task_que(void *pv)  //  void *pv - указатель, который мы передаем в функцию при создании задачи, содержит в себе имя задачи с указанием на константу
{
  char *task_name = (char*)pv;  //  присваиваем значение передаваемого указателя с константы в переменную *task_name 
  // так как в с++ нет строковых переменных, используется указатель на ячейку памяти, откуда будут браться значения символов, получается своеобразная "строка"
  int received_count;   //  объявляем локальную переменную для хранения значений, полученных из очереди

  if (strcmp(task_name, "Задание2")== 0)  //  если выполняется задание2, то делаем ему отсрочку
  // в данном случае для задания 2 получаем отсрочку в ~1 секунду, чтобы изначально оно было смещено для удобного наблюдения выполнения заданий
    vTaskDelay(1000);

  while (true)  //  зацикливаем задачу, чтобы она "не закончилась"
  {  
    //  если при обращении к очереди в течение 10мс мы получили данные
    if (xQueueReceive(Ochered, &received_count, 10) != pdFALSE)
    {
      //  запускаем функцию вывода сообщений с передачей параметров:
      //  имя задачи и, полученное из очереди значение
      send_data2port(task_name, &received_count);
      //после успешного получения можно увеличивать счетчик на 1;
      count += 1;
    } else
        //  если мы ничего не получили из очереди
        //  запускаем функцию вывода сообщений с указанием задачи
        que_error_receive(task_name);

    //  отправляем увеличенное значение счетчика в очередь
    //  если в течение 10мс нам это не удастся, то вызовем функцию
    //  которая выведет данные в серийный порт с именем задачи
    if (xQueueSend(Ochered, &count, 10) == pdFALSE)
      que_error_send(task_name);

    //если это задание2, а не задание1, то вызываем задание3 через семафор
    if (strcmp(task_name, "Задание2")== 0)
      xSemaphoreGive(Semafor);

    //  задержка в ~3 секунды используется для создания равного времени для вывода на каждую задачу по ~1сек.
    vTaskDelay(3000);
  }
}

//  задание3 с выполнением по сигналу (семафору)
void task_sema(void *pv)
{
  char *task_name = (char*)pv;  //  объявляем указатель типа char для имитации строковой переменной и получаем значение, переданное при создании задачи
  int received_count; //  объявляем локальную переменную для получения данных из очереди
  
  while (true)
  {
    //  если получили сигнал для выполнения задачи без ошибок в течение 10мс (тоесть никакая другая задача не выполняется по сигналу с этим указателем)
    if(xSemaphoreTake(Semafor, 10) == pdTRUE)
    {
      vTaskDelay(1000); //  ждем 1секунду, так как задача3 начала выполняться сразу после задачи2, нужна "отсечка"
      if (xQueueReceive(Ochered, &received_count, 10) != pdFALSE)  // Если при обращении к очереди в течение 10мс мы не получили ошибку
      {
        //  вызываем функцию вывода сообщения с именем задачи и полученным значением
        send_data2port(task_name, &received_count);
        //  увеличиваем счетчик 
        count += 1;
      }
        else
          //  если при обращении к очереди для получения данных мы не получили ответа в течение 10мс, 
          //  вызываем вывод сообщения с ошибкой указания задачи
          que_error_receive(task_name);

        //  если при обращении к очереди для отправки данных мы не получили ответа в течение 10мс, 
        //  вызываем вывод сообщения с ошибкой указания задачи
      if (xQueueSend(Ochered, &count, 10) == pdFALSE)
        que_error_send(task_name);
    }
  }
}

// функция для вывода сообщений с принимаемыми 2 параметрами
// param1 - имя задачи
// param2 - принимаемое значение
void send_data2port(void *param1, void *param2)
{
  //  для вывода сообщений в серийный порт, используем мьютекс,
  //  это нужно чтоб сообщения "не потерялись" и "не перемешались"
  if (xSemaphoreTake(Mutex, 10) == pdTRUE)
  {
    char *task_name = (char*)param1;
    int *task_data = (int*)param2;
    Serial.print(task_name);
    Serial.print("; счетчик = ");
    Serial.println(*task_data);
    xSemaphoreGive(Mutex);
  } else
    //  но если мьютекс занят, шлем на вывод что есть, будем смотреть что получится, попробуем увеличить время до 100/1000мс
    //  если мы укажем параметр portMAX_DELAY = есть вероятность, что задача навечно зависнет
    Serial.println("Мьютекс занят, подождите");
}

// функция для обработки ошибок отправки очереди
void que_error_send(void *param1)
{
  // для вывода используем переданный параметр с именем задачи
  char *task_name = (char*)param1;
  //  блокируем серийный порт мьютексом для вывода сообщения об ошибке
  if (xSemaphoreTake(Mutex, 100) == pdTRUE)
  {
    Serial.print("Ошибка отправки в очередь: ");
    Serial.println(task_name);
    //  отпускаем мьютекс
    xSemaphoreGive(Mutex);
  } 
}

//  аналогично для обработки ошибок приема очереди
void que_error_receive(void *param1)
{
  char *task_name = (char*)param1;
  if (xSemaphoreTake(Mutex, 100) == pdTRUE)
  {
    Serial.print("Ошибка получения очереди: ");
    Serial.print(task_name);
    xSemaphoreGive(Mutex);
  }
}
